From 6662657f9ee672edb226c12e7b48fa6c48499438 Mon Sep 17 00:00:00 2001
From: vo17245 <87613099+vo17245@users.noreply.github.com>
Date: Tue, 19 Aug 2025 19:02:05 +0800
Subject: [PATCH] tmp

---
 CMakeLists.txt                                |   9 +-
 Core/src/Core/Base.h                          |  16 +-
 Core/src/Core/NotNull.h                       |   2 +-
 Core/src/Core/TypeArray.h                     |   9 +-
 Core/src/Core/TypeTraits.h                    |  13 +-
 Demo/TextDemo/src/TextLayer.h                 | 200 +++++-------
 Entry/src/Entry/Application.h                 |   1 -
 Entry/src/Entry/main.cpp                      |   2 +-
 Render/src/Render/Config.cpp                  |   2 +-
 Render/src/Render/RenderApi/DeviceBuffer.h    |  19 ++
 .../RenderGraph/ImageLayoutTransitionTask.h   |   7 +
 Render/src/Render/RenderGraph/RenderGraph.cpp |  93 ++++--
 Render/src/Render/RenderGraph/RenderGraph.h   |  69 ++--
 Render/src/Render/RenderGraph/RenderTask.h    |  10 +-
 .../RenderGraph/Resource/ResourceAccessor.h   | 134 +++++---
 .../RenderGraph/Resource/ResourceLruPool.h    |   2 +-
 .../RenderGraph/Resource/VirtualResource.h    |   7 +-
 Render/src/Render/Vulkan/Buffer.cpp           |  17 -
 Render/src/Render/Vulkan/Buffer.h             |   2 +
 .../src/Render/Vulkan/GlobalRenderContext.cpp |   1 +
 Render/src/Render/Vulkan/RenderContext.cpp    |   2 -
 Render/src/Render/Vulkan/Transfer.cpp         |  13 +
 Render/src/Render/Vulkan/Transfer.h           |   7 +
 .../CreateProjectWithTestsAndDemoDebug.bat    |   6 +
 Sprite/CMakeLists.txt                         |   8 +-
 Sprite/{Source => src}/Sprite/Atlas.cpp       |   0
 Sprite/{Source => src}/Sprite/Atlas.h         |   0
 Sprite/{Source => src}/Sprite/Quad.h          |   0
 Sprite/{Source => src}/Sprite/Renderer.cpp    |   0
 Sprite/{Source => src}/Sprite/Renderer.h      |   0
 .../RenderGraphTests/src/RenderGraphTests.cpp | 103 ++----
 Window/src/Window/GammaFilter.cpp             |  18 +-
 Window/src/Window/GammaFilter.h               |  21 +-
 Window/src/Window/Layer.h                     |  12 +-
 Window/src/Window/Window.cpp                  | 296 ++++++++++--------
 Window/src/Window/Window.h                    |  51 ++-
 36 files changed, 622 insertions(+), 530 deletions(-)
 create mode 100644 Render/src/Render/Vulkan/Transfer.cpp
 create mode 100644 Render/src/Render/Vulkan/Transfer.h
 create mode 100644 Scripts/CreateProjectWithTestsAndDemoDebug.bat
 rename Sprite/{Source => src}/Sprite/Atlas.cpp (100%)
 rename Sprite/{Source => src}/Sprite/Atlas.h (100%)
 rename Sprite/{Source => src}/Sprite/Quad.h (100%)
 rename Sprite/{Source => src}/Sprite/Renderer.cpp (100%)
 rename Sprite/{Source => src}/Sprite/Renderer.h (100%)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e278682..2d946c0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -21,14 +21,17 @@ add_subdirectory("Resource")
 add_subdirectory("IO")
 add_subdirectory("Dependencies")
 add_subdirectory("Entry")
-add_subdirectory("Demo")
-add_subdirectory("Tests")
 add_subdirectory("Scene")
 add_subdirectory("Text")
 add_subdirectory("Debug")
 add_subdirectory("Audio")
 
-
+if(AETHER_BUILD_DEMO)
+add_subdirectory("Demo")
+endif()
+if(AETHER_BUILD_TESTS)
+add_subdirectory("Tests")
+endif()
 
 install(DIRECTORY "${CMAKE_SOURCE_DIR}/Vendor/"
     DESTINATION Vendor
diff --git a/Core/src/Core/Base.h b/Core/src/Core/Base.h
index 97c26b6..07a2a67 100644
--- a/Core/src/Core/Base.h
+++ b/Core/src/Core/Base.h
@@ -3,7 +3,7 @@
 #include <memory>
 #include <ranges>
 #include <vector>
-
+#include <tuple>
 // clang-format on
 namespace Aether
 {
@@ -51,4 +51,18 @@ inline constexpr bool IsFlagSet(T flags, U flag)
 {
     return (flags & static_cast<std::underlying_type_t<U>>(flag)) ;
 }
+namespace Detail
+{
+template<typename T,typename F, size_t... Is>
+inline constexpr void ForEachInTupleImpl(T&& tuple, F&& f, std::index_sequence<Is...>)
+{
+    (f(std::get<Is>(std::forward<T>(tuple))) , ...);
+}
+}
+template<typename Tuple,typename F>
+inline constexpr void ForEachInTuple(Tuple&& tuple,F&& f)
+{
+    using Indices = std::make_index_sequence<std::tuple_size_v<std::decay_t<Tuple>>>;
+    Detail::ForEachInTupleImpl(std::forward<Tuple>(tuple), std::forward<F>(f), Indices{});
+}
 } // namespace Aether
diff --git a/Core/src/Core/NotNull.h b/Core/src/Core/NotNull.h
index 5fbb9a0..76b6a4e 100644
--- a/Core/src/Core/NotNull.h
+++ b/Core/src/Core/NotNull.h
@@ -21,7 +21,7 @@ public:
     NotNull& operator=(std::nullptr_t) = delete;
     template <typename U>
     requires std::is_base_of_v<T, U>
-    NotNull(const NotNull<U>& other) : m_Ptr(other.m_Ptr)
+    NotNull(U* ptr) : m_Ptr(ptr)
     {
     }
     NotNull(T& v) : m_Ptr(&v)
diff --git a/Core/src/Core/TypeArray.h b/Core/src/Core/TypeArray.h
index bab8247..ff2614b 100644
--- a/Core/src/Core/TypeArray.h
+++ b/Core/src/Core/TypeArray.h
@@ -2,6 +2,7 @@
 #include <cstdint>
 #include <type_traits>
 #include <cstddef>
+#include <tuple>
 namespace Aether
 {
 template <typename T, typename... Ts>
@@ -64,5 +65,11 @@ struct IsArrayContainType<T, TypeArray<Ts...>>
 {
     static constexpr bool value = IsContainType<T, Ts...>::value;
 };
-
+template<typename T>
+struct TypeArrayToTuple;
+template<typename... Ts>
+struct TypeArrayToTuple<TypeArray<Ts...>>
+{
+    using Type = std::tuple<Ts...>;
+};
 } // namespace Aether
\ No newline at end of file
diff --git a/Core/src/Core/TypeTraits.h b/Core/src/Core/TypeTraits.h
index a48b712..95e091e 100644
--- a/Core/src/Core/TypeTraits.h
+++ b/Core/src/Core/TypeTraits.h
@@ -1,19 +1,10 @@
 #pragma once
 #include <tuple>
+#include "TypeArray.h"
 namespace Aether
 {
 template <typename T>
 constexpr bool always_false_v = false;
-template <typename... Ts>
-struct TypeArray
-{
-};
-template<typename T>
-struct TypeArrayToTuple;
-template<typename... Ts>
-struct TypeArrayToTuple<TypeArray<Ts...>>
-{
-    using Type = std::tuple<Ts...>;
-};
+
 
 } // namespace Aether
\ No newline at end of file
diff --git a/Demo/TextDemo/src/TextLayer.h b/Demo/TextDemo/src/TextLayer.h
index 40bc210..15f70f7 100644
--- a/Demo/TextDemo/src/TextLayer.h
+++ b/Demo/TextDemo/src/TextLayer.h
@@ -6,8 +6,8 @@
 #include "Window/WindowEvent.h"
 #include <Core/String.h>
 #include <variant>
-#include <Render/TaskGraph.h>
 #include "DownsamplingRenderPass.h"
+#include <Render/RenderGraph/RenderGraph.h>
 #ifdef DrawText
 #undef DrawText
 #endif
@@ -26,27 +26,21 @@ public:
             camera.screenSize.y() = resizeEvent.GetHeight();
             camera.target.x() = resizeEvent.GetWidth() / 2.0;
             camera.target.y() = resizeEvent.GetHeight() / 2.0;
-            {
-                auto texture = DeviceTexture::CreateForColorAttachment(m_Window->GetSize().x() * 4,
-                                                                       m_Window->GetSize().y() * 4,
-                                                                       PixelFormat::RGBA8888);
-                m_OversamplingTexture = CreateScope<DeviceTexture>(std::move(texture.value()));
-                m_TgOversamplingTexture->GetDesc().width = m_Window->GetSize().x() * 4;
-                m_TgOversamplingTexture->GetDesc().height = m_Window->GetSize().y() * 4;
-                m_TgOversamplingTexture->SetActualBorrow(m_OversamplingTexture.get());
-                m_TgFinalTexture->GetDesc().width = m_Window->GetSize().x();
-                m_TgFinalTexture->GetDesc().height = m_Window->GetSize().y();
-                m_TgFinalTexture->SetActualBorrow(m_Window->GetFinalTexture());
-            }
         }
     }
-    virtual void OnRender(
-        vk::RenderPass& renderPass,
-        vk::FrameBuffer& framebuffer,
-        vk::GraphicsCommandBuffer& commandBuffer) override
+    virtual void RegisterRenderPasses(RenderGraph::RenderGraph& renderGraph)override
     {
-        m_TaskGraph.SetCommandBuffer(commandBuffer);
-        m_TaskGraph.Execute();
+        auto finalImage = m_Window->GetFinalImageAccessId();
+        // draw text to final image
+        struct TaskData
+        {
+        };
+        renderGraph.AddRenderTask<TaskData>(
+            [&](RenderGraph::RenderTaskBuilder& builder, TaskData& data) {
+            },
+            [](DeviceCommandBuffer& commandBuffer, RenderGraph::ResourceAccessor& accessor, TaskData& data) {
+
+            });
     }
     virtual void OnAttach(Window* window) override
     {
@@ -62,36 +56,12 @@ public:
         }
         {
             auto texture = DeviceTexture::CreateForColorAttachment(m_Window->GetSize().x() * 4,
-                                                                   m_Window->GetSize().y() * 4,
-                                                                   PixelFormat::RGBA8888);
+                                                                   m_Window->GetSize().y() * 4, PixelFormat::RGBA8888);
             m_OversamplingTexture = CreateScope<DeviceTexture>(std::move(texture.value()));
         }
-        m_TgOversamplingTexture = m_TaskGraph.AddRetainedTextureBorrow("oversampling texture",
-                                                                       m_OversamplingTexture.get(),
-                                                                       DeviceImageLayout::Undefined);
-        m_TgFinalTexture = m_TaskGraph.AddRetainedTextureBorrow("final image",
-                                                                window->GetFinalTexture(),
-                                                                DeviceImageLayout::ColorAttachment);
-
-        // DrawText(m_TgOversamplingTexture);
-        DrawText(m_TgFinalTexture);
-        // Downsampling(m_TgFinalTexture, m_TgOversamplingTexture);
-        m_TaskGraph.Compile();
     }
-    void Downsampling(TaskGraph::Texture* finalTexture, TaskGraph::Texture* oversamplingTexture)
-    {
-        struct TaskData
-        {
-        };
-        TaskGraph::RenderPassDesc renderPassDesc;
-        renderPassDesc.colorAttachmentCount = 1;
-        renderPassDesc.colorAttachment[0].texture = finalTexture;
-        renderPassDesc.colorAttachment[0].loadOp = DeviceAttachmentLoadOp::Clear;
-        renderPassDesc.colorAttachment[0].storeOp = DeviceAttachmentStoreOp::Store;
-        renderPassDesc.clearColor = Vec4f{1.0, 1.0, 1.0, 1.0};
-        m_TaskGraph.AddRenderTask<TaskData>(renderPassDesc, [&](TaskGraph::RenderTaskBuilder& builder, TaskData&) { builder.Read(oversamplingTexture); }, [this, oversamplingTexture](TaskData&, DeviceCommandBufferView& commandBuffer) { m_Downsampling->Render(commandBuffer, *oversamplingTexture->GetActual(), ApplicationResource::GetSingleton().descriptorPool); });
-    }
-    void DrawText(TaskGraph::Texture* oversamplingTexture)
+
+    void DrawText(RenderGraph::AccessId<DeviceTexture> finalImage,RenderGraph::RenderGraph& renderGraph)
     {
         {
             struct TaskData
@@ -103,80 +73,81 @@ public:
             renderPassDesc.colorAttachment[0].loadOp = DeviceAttachmentLoadOp::Clear;
             renderPassDesc.colorAttachment[0].storeOp = DeviceAttachmentStoreOp::Store;
             renderPassDesc.clearColor = Vec4f{1.0, 1.0, 1.0, 1.0};
-            m_TaskGraph.AddRenderTask<TaskData>(renderPassDesc, [&](TaskGraph::RenderTaskBuilder& builder, TaskData&) {
+            m_TaskGraph.AddRenderTask<TaskData>(
+                renderPassDesc,
+                [&](TaskGraph::RenderTaskBuilder& builder, TaskData&) {
 
-            },
-                                                [this](TaskData&, DeviceCommandBufferView& commandBuffer) {
-float framePerSec = m_Frame / m_Sec;
-        std::string s = std::string("") + "fps: " + std::to_string(framePerSec) + "\n"
-                        + "我能吞下玻璃而不伤身体\n"
-                        + "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n";
+                },
+                [this](TaskData&, DeviceCommandBufferView& commandBuffer) {
+                    float framePerSec = m_Frame / m_Sec;
+                    std::string s = std::string("") + "fps: " + std::to_string(framePerSec) + "\n"
+                                    + "我能吞下玻璃而不伤身体\n"
+                                    + "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n";
 
+                    // get glyph curve
+                    Text::StrokeParam strokeParam;
+                    strokeParam.radius = 32;
+                    auto lines = ApplicationResource::GetSingleton().font->prepareGlyphsForText(s, {});
 
-        // get glyph curve
-        Text::StrokeParam strokeParam;
-        strokeParam.radius=32;
-        auto lines=ApplicationResource::GetSingleton().font->prepareGlyphsForText(s,
-            {});
+                    size_t glyphCount = 0;
+                    for (auto& line : lines)
+                    {
+                        glyphCount += line.visualGlyphs.size();
+                    }
+                    // calculate glyph layout
+                    std::vector<Vec2f> glyphPos;
+                    std::vector<uint32_t> glyphToRender;
+                    glyphPos.reserve(glyphCount);
+                    float worldSize = 32.0f;
+                    {
+                        float x = 0;
+                        float y = 0;
+                        float width = 700;
 
-        size_t glyphCount = 0;
-        for (auto& line : lines)
-        {
-            glyphCount += line.visualGlyphs.size();
-        }
-        // calculate glyph layout
-        std::vector<Vec2f> glyphPos;
-        std::vector<uint32_t> glyphToRender;
-        glyphPos.reserve(glyphCount);
-        float worldSize = 32.0f;
-        {
-            
-            float x = 0;
-            float y = 0;
-            float width = 700;
-            
-            for (auto& line : lines)
-            {
-                for(auto& glyph:line.visualGlyphs)
-                {
-                    auto& info= ApplicationResource::GetSingleton().font->bufferGlyphInfo[glyph.indexInBuffer];
-                    float emSize = info.emSize;
-                    float scale = worldSize / emSize;
-                   
-                    glyphToRender.push_back(glyph.indexInBuffer);
-                    glyphPos.push_back(Vec2f(x+(glyph.xOffset+info.bearingX)*scale, y + (emSize-info.bearingY-glyph.yOffset ) * scale));
-                    x += glyph.xAdvance  * scale;
-                    y+= glyph.yAdvance * scale;
-                    if (x > width)
+                        for (auto& line : lines)
+                        {
+                            for (auto& glyph : line.visualGlyphs)
+                            {
+                                auto& info =
+                                    ApplicationResource::GetSingleton().font->bufferGlyphInfo[glyph.indexInBuffer];
+                                float emSize = info.emSize;
+                                float scale = worldSize / emSize;
+
+                                glyphToRender.push_back(glyph.indexInBuffer);
+                                glyphPos.push_back(Vec2f(x + (glyph.xOffset + info.bearingX) * scale,
+                                                         y + (emSize - info.bearingY - glyph.yOffset) * scale));
+                                x += glyph.xAdvance * scale;
+                                y += glyph.yAdvance * scale;
+                                if (x > width)
+                                {
+                                    x = 0;
+                                    y += worldSize;
+                                }
+                            }
+                            x = 0;
+                            y += worldSize;
+                        }
+                    }
+                    if (glyphToRender.empty())
                     {
-                        x = 0;
-                        y += worldSize;
+                        return;
                     }
-                }
-                x = 0;
-                y += worldSize;
-              
-            }
-        }
-        if(glyphToRender.empty())
-        {
-            return;
-        }
-        auto& camera = ApplicationResource::GetSingleton().camera;
-        camera.CalculateMatrix();
-        Text::Raster::RenderPassParam param{
-            .commandBuffer = commandBuffer,
-            .descriptorPool = ApplicationResource::GetSingleton().descriptorPool,
-            .font = *ApplicationResource::GetSingleton().font,
-            .bufferGlyphInfoIndexes = glyphToRender,
-            .glyphPosition = glyphPos,
-            .worldSize = worldSize,
-            .camera = camera,
-            .z = 0.0f};
-        param.color = Vec3f(0, 0, 0);
+                    auto& camera = ApplicationResource::GetSingleton().camera;
+                    camera.CalculateMatrix();
+                    Text::Raster::RenderPassParam param{.commandBuffer = commandBuffer,
+                                                        .descriptorPool =
+                                                            ApplicationResource::GetSingleton().descriptorPool,
+                                                        .font = *ApplicationResource::GetSingleton().font,
+                                                        .bufferGlyphInfoIndexes = glyphToRender,
+                                                        .glyphPosition = glyphPos,
+                                                        .worldSize = worldSize,
+                                                        .camera = camera,
+                                                        .z = 0.0f};
+                    param.color = Vec3f(0, 0, 0);
 
-        ApplicationResource::GetSingleton().textRaster->Render(param,
-                                                               *ApplicationResource::GetSingleton().rasterResource); });
+                    ApplicationResource::GetSingleton().textRaster->Render(
+                        param, *ApplicationResource::GetSingleton().rasterResource);
+                });
         }
     }
     virtual void OnUpdate(float sec) override
@@ -190,8 +161,5 @@ private:
     float m_Sec = 0;
     uint32_t m_Frame = 0;
     Scope<DeviceTexture> m_OversamplingTexture;
-    TaskGraph::TaskGraph m_TaskGraph;
     Scope<DownsamplingRenderPass> m_Downsampling;
-    TaskGraph::Texture* m_TgFinalTexture = nullptr;
-    TaskGraph::Texture* m_TgOversamplingTexture = nullptr;
 };
\ No newline at end of file
diff --git a/Entry/src/Entry/Application.h b/Entry/src/Entry/Application.h
index 1228a72..929c002 100644
--- a/Entry/src/Entry/Application.h
+++ b/Entry/src/Entry/Application.h
@@ -15,7 +15,6 @@ namespace Aether
         }
         virtual void OnFrameBegin()
         {
-            // e.q. clear last frame temporary resource
         }
         virtual const char* GetName()const
         {
diff --git a/Entry/src/Entry/main.cpp b/Entry/src/Entry/main.cpp
index cc67e27..b509176 100644
--- a/Entry/src/Entry/main.cpp
+++ b/Entry/src/Entry/main.cpp
@@ -28,7 +28,7 @@ int main()
         std::chrono::high_resolution_clock::time_point lastTime = std::chrono::high_resolution_clock::now();
         while (!window->ShouldClose())
         {
-            window->WaitLastFrameComplete();
+            //window->WaitLastFrameComplete();
             app->OnFrameBegin();
 
             WindowContext::PollEvents();
diff --git a/Render/src/Render/Config.cpp b/Render/src/Render/Config.cpp
index 317a928..49967e9 100644
--- a/Render/src/Render/Config.cpp
+++ b/Render/src/Render/Config.cpp
@@ -7,6 +7,6 @@ namespace Aether
         Api Config::RenderApi=Api::Vulkan;
         int Config::VulkanApiVersion=VK_API_VERSION_1_3;
         int Config::VulkanApiVersionNumber=130;
-        int Config::MaxFramesInFlight=3;
+        int Config::MaxFramesInFlight=2;
     }
 }
\ No newline at end of file
diff --git a/Render/src/Render/RenderApi/DeviceBuffer.h b/Render/src/Render/RenderApi/DeviceBuffer.h
index f5b1137..a0602a8 100644
--- a/Render/src/Render/RenderApi/DeviceBuffer.h
+++ b/Render/src/Render/RenderApi/DeviceBuffer.h
@@ -4,6 +4,8 @@
 #include "Render/Config.h"
 #include "Render/Vulkan/GlobalRenderContext.h"
 #include <variant>
+#include "Render/Vulkan/Transfer.h"
+#include "DeviceCommandBuffer.h"
 namespace Aether
 {
 class DeviceBuffer
@@ -176,6 +178,23 @@ public:
     {
         return !Empty();
     }
+    static bool AsyncCopy(DeviceCommandBuffer& commandBuffer, DeviceBuffer& src, DeviceBuffer& dst, size_t size,
+                          size_t srcOffset, size_t dstOffset)
+    {
+        switch (Render::Config::RenderApi)
+        {
+        case Render::Api::Vulkan: {
+            auto& vkSrc= src.GetVk();
+            auto& vkDst= dst.GetVk();
+            vk::AsyncCopyBuffer(commandBuffer.GetVk(), vkSrc, vkDst, size, srcOffset, dstOffset);
+        }
+        break;
+        default:
+            assert(false && "Not implemented");
+            return false;
+        }
+        return true;
+    }
 
 private:
     std::variant<std::monostate, vk::Buffer> m_Buffer;
diff --git a/Render/src/Render/RenderGraph/ImageLayoutTransitionTask.h b/Render/src/Render/RenderGraph/ImageLayoutTransitionTask.h
index 1305441..41475b2 100644
--- a/Render/src/Render/RenderGraph/ImageLayoutTransitionTask.h
+++ b/Render/src/Render/RenderGraph/ImageLayoutTransitionTask.h
@@ -2,6 +2,8 @@
 #include "Resource/AccessId.h"
 #include <Render/RenderApi.h>
 #include "TaskBase.h"
+#include "Resource/DeviceTexture.h"
+#include "Resource/ResourceAccessor.h"
 namespace Aether::RenderGraph
 {
     struct ImageLayoutTransitionTask:public TaskBase
@@ -10,5 +12,10 @@ namespace Aether::RenderGraph
         AccessId<DeviceTexture> texture;
         DeviceImageLayout oldLayout;
         DeviceImageLayout newLayout;
+        void Execute(DeviceCommandBuffer& commandBuffer, ResourceAccessor& resourceAccessor) 
+        {
+            auto* textureActual= resourceAccessor.GetResource(texture);
+            textureActual->AsyncTransitionLayout(oldLayout, newLayout, commandBuffer);
+        }
     };
 }
\ No newline at end of file
diff --git a/Render/src/Render/RenderGraph/RenderGraph.cpp b/Render/src/Render/RenderGraph/RenderGraph.cpp
index 3ad521e..5b8b799 100644
--- a/Render/src/Render/RenderGraph/RenderGraph.cpp
+++ b/Render/src/Render/RenderGraph/RenderGraph.cpp
@@ -28,7 +28,7 @@ void RenderGraph::CullTasks()
     std::stack<VirtualResourceBase*> unreferencedResources;
     for (auto& resource : m_Resources)
     {
-        if (resource->refCount == 0 && resource->creator == nullptr)
+        if (resource->refCount == 0 && resource->Transient())
             unreferencedResources.push(resource.get());
     }
 
@@ -51,7 +51,7 @@ void RenderGraph::CullTasks()
                 {
                     read_resource->refCount--;
                 }
-                if (read_resource->refCount == 0 && read_resource->creator == nullptr)
+                if (read_resource->refCount == 0 && read_resource->Transient())
                     unreferencedResources.push(read_resource);
             }
         }
@@ -72,7 +72,7 @@ void RenderGraph::CullTasks()
                     {
                         read_resource->refCount--;
                     }
-                    if (read_resource->refCount == 0 && read_resource->creator == nullptr)
+                    if (read_resource->refCount == 0 && read_resource->Transient())
                     {
                         unreferencedResources.push(read_resource);
                     }
@@ -143,15 +143,23 @@ void RenderGraph::PerformResourceAliasing()
     // caculate last access task index in m_Steps for each resource
     for (auto& resource : m_Resources)
     {
-        auto lastReader = std::find_if(m_Steps.begin(), m_Steps.end(),
-                                       [&](const TaskBase* task) { return task == resource->readers.back().Get(); });
-        assert(lastReader != m_Steps.end());
-        resource->lastAccessTaskIndex = std::distance(m_Steps.begin(), lastReader);
-        auto lastWriter = std::find_if(m_Steps.begin(), m_Steps.end(),
-                                       [&](const TaskBase* task) { return task == resource->writers.back().Get(); });
-        assert(lastWriter != m_Steps.end());
-        resource->lastAccessTaskIndex =
-            std::max(resource->lastAccessTaskIndex, size_t(std::distance(m_Steps.begin(), lastWriter)));
+        if (!resource->readers.empty())
+        {
+            auto lastReader = std::find_if(m_Steps.begin(), m_Steps.end(), [&](const TaskBase* task) {
+                return task == resource->readers.back().Get();
+            });
+            assert(lastReader != m_Steps.end());
+            resource->lastAccessTaskIndex = std::distance(m_Steps.begin(), lastReader);
+        }
+        if (!resource->writers.empty())
+        {
+            auto lastWriter = std::find_if(m_Steps.begin(), m_Steps.end(), [&](const TaskBase* task) {
+                return task == resource->writers.back().Get();
+            });
+            assert(lastWriter != m_Steps.end());
+            resource->lastAccessTaskIndex =
+                std::max(resource->lastAccessTaskIndex, int64_t(std::distance(m_Steps.begin(), lastWriter)));
+        }
     }
     // perform resource aliasing
     auto pool = Detail::VirtualResourcePool();
@@ -178,7 +186,7 @@ void RenderGraph::PerformResourceAliasing()
         // push dead resources to the pool
         for (auto& resource : task->reads)
         {
-            if (resource->lastAccessTaskIndex == i)
+            if (resource->lastAccessTaskIndex <= (int64_t)i)
             {
                 VisitVirtualResource(*resource, [&](auto&& r) -> void {
                     using ResourceType = typename std::decay_t<decltype(r)>::ResourceType;
@@ -188,7 +196,7 @@ void RenderGraph::PerformResourceAliasing()
         }
         for (auto& resource : task->writes)
         {
-            if (resource->lastAccessTaskIndex == i)
+            if (resource->lastAccessTaskIndex <= (int64_t)i)
             {
                 VisitVirtualResource(*resource, [&](auto&& r) -> void {
                     using ResourceType = typename std::decay_t<decltype(r)>::ResourceType;
@@ -298,6 +306,26 @@ void RenderGraph::InsertImageLayoutTransition()
         // add the task to new steps
         newSteps.push_back(&task);
     }
+    // restore image layout
+    for (auto& resource : m_Resources)
+    {
+        if (resource->code != ResourceCode::Texture)
+        {
+            continue;
+        }
+        auto& texture = static_cast<VirtualResource<DeviceTexture>&>(*resource);
+        auto& slot = m_ResourceAccessor->GetSlot(texture.id);
+        if (slot.virtualInfo.layout != texture.desc.layout)
+        {
+            auto transitionTask = CreateScope<ImageLayoutTransitionTask>();
+            transitionTask->texture = texture.id;
+            transitionTask->oldLayout = slot.virtualInfo.layout;
+            transitionTask->newLayout = texture.desc.layout;
+            m_Tasks.push_back(std::move(transitionTask));
+            newSteps.push_back(m_Tasks.back().get());
+            slot.virtualInfo.layout = texture.desc.layout;
+        }
+    }
 }
 void RenderGraph::MergeRenderPasses()
 {
@@ -358,6 +386,7 @@ void RenderGraph::SetResourceSlotSupportsInFlightResources()
         {
             auto& imageView = static_cast<VirtualResource<DeviceImageView>&>(*resource);
             auto textureId = imageView.desc.texture;
+            assert(m_AccessIdToResourceIndex.contains(textureId.handle)&&"Texture resource not found");
             auto& virtualResource = *m_Resources[m_AccessIdToResourceIndex[textureId.handle]];
             assert(virtualResource.code == ResourceCode::Texture);
             if (virtualResource.writers.empty())
@@ -424,25 +453,25 @@ DeviceRenderPassDesc RenderGraph::RenderPassDescToDeviceRenderPassDesc(const Ren
 FrameBufferDesc RenderGraph::RenderPassDescToFrameBufferDesc(const RenderPassDesc& desc)
 {
     FrameBufferDesc framebufferDesc;
-    framebufferDesc.colorAttachmentCount=desc.colorAttachmentCount;
-    framebufferDesc.width=desc.width;
-    framebufferDesc.height=desc.height;
-    for(size_t i=0;i<framebufferDesc.colorAttachmentCount;++i)
+    framebufferDesc.colorAttachmentCount = desc.colorAttachmentCount;
+    framebufferDesc.width = desc.width;
+    framebufferDesc.height = desc.height;
+    for (size_t i = 0; i < framebufferDesc.colorAttachmentCount; ++i)
     {
-        auto& frameBufferAttachment=framebufferDesc.colorAttachments[i];
-        auto& attachment=desc.colorAttachment[i];
-        frameBufferAttachment.imageView=attachment.imageView;
-        frameBufferAttachment.loadOp=attachment.loadOp;
-        frameBufferAttachment.storeOp=attachment.storeOp;
+        auto& frameBufferAttachment = framebufferDesc.colorAttachments[i];
+        auto& attachment = desc.colorAttachment[i];
+        frameBufferAttachment.imageView = attachment.imageView;
+        frameBufferAttachment.loadOp = attachment.loadOp;
+        frameBufferAttachment.storeOp = attachment.storeOp;
     }
-    if(desc.depthAttachment)
+    if (desc.depthAttachment)
     {
-        auto depthAttachment=Attachment();
-        auto& attachment=*desc.depthAttachment;
-        depthAttachment.imageView=attachment.imageView;
-        depthAttachment.loadOp=attachment.loadOp;
-        depthAttachment.storeOp=attachment.storeOp;
-        framebufferDesc.depthAttachment=depthAttachment;
+        auto depthAttachment = Attachment();
+        auto& attachment = *desc.depthAttachment;
+        depthAttachment.imageView = attachment.imageView;
+        depthAttachment.loadOp = attachment.loadOp;
+        depthAttachment.storeOp = attachment.storeOp;
+        framebufferDesc.depthAttachment = depthAttachment;
     }
     return framebufferDesc;
 }
@@ -458,6 +487,10 @@ void RenderGraph::Execute()
             renderTask.Execute(*m_CommandBuffer, *m_ResourceAccessor);
         }
         break;
+        case TaskType::ImageLayoutTransitionTask: {
+            auto& transitionTask = static_cast<ImageLayoutTransitionTask&>(task);
+            transitionTask.Execute(*m_CommandBuffer, *m_ResourceAccessor);
+        }
         default:
             assert(false && "Unsupported task type in RenderGraph::Execute");
         }
diff --git a/Render/src/Render/RenderGraph/RenderGraph.h b/Render/src/Render/RenderGraph/RenderGraph.h
index c78977c..fe0ebe6 100644
--- a/Render/src/Render/RenderGraph/RenderGraph.h
+++ b/Render/src/Render/RenderGraph/RenderGraph.h
@@ -32,6 +32,9 @@ public:
     }
 
     void Compile();
+    void SetCurrentFrame(uint32_t frame)
+    {
+    }
     void Execute();
     void SetCommandBuffer(DeviceCommandBuffer* commandBuffer)
     {
@@ -41,12 +44,23 @@ public:
     {
         return *m_ResourceAccessor;
     }
-    template <typename ResourceType, typename... Resources>
-        requires(IsResource<ResourceType>::value
-                 && (std::is_same_v<std::remove_cvref_t<Resources>, ResourceType*> && ...))
-    AccessId<ResourceType> Import(const typename ResourceDescType<ResourceType>::Type& desc, Resources... resources)
+    template <typename ResourceType>
+        requires(IsResource<ResourceType>::value)
+    AccessId<ResourceType> Import(const typename ResourceDescType<ResourceType>::Type& desc,
+                                  const std::span<ResourceId<ResourceType>>& ids)
     {
-        assert(false && "not implemented");
+        auto& slot = m_ResourceAccessor->CreateSlot<ResourceType>(desc);
+        for (size_t i = 0; i < ids.size(); ++i)
+        {
+            slot.frameResources[i] = ids[i];
+            slot.isRealized[i] = true;
+        }
+        slot.resourceCount = static_cast<uint32_t>(ids.size());
+        slot.external=true;
+        auto virtualResource = CreateScope<VirtualResource<ResourceType>>(desc, slot.id);
+        m_AccessIdToResourceIndex[slot.id.handle] = static_cast<uint32_t>(m_Resources.size());
+        m_Resources.push_back(std::move(virtualResource));
+        return slot.id;
     }
 
 private:
@@ -67,6 +81,7 @@ private:
 private:
     DeviceRenderPassDesc RenderPassDescToDeviceRenderPassDesc(const RenderPassDesc& desc);
     FrameBufferDesc RenderPassDescToFrameBufferDesc(const RenderPassDesc& desc);
+
 private:
     DeviceCommandBuffer* m_CommandBuffer = nullptr;
     Borrow<ResourceArena> m_ResourceArena;
@@ -131,30 +146,32 @@ inline RenderTaskBuilder& RenderTaskBuilder::SetRenderPassDesc(const RenderPassD
         read(desc.depthAttachment->imageView.handle);
     }
     // allocate render pass
-    auto renderPassDesc=m_Graph.RenderPassDescToDeviceRenderPassDesc(desc);
-    auto virtualRenderPassPtr=CreateScope<VirtualResource<DeviceRenderPass>>();
-    auto& virtualRenderPass=*virtualRenderPassPtr;
-    virtualRenderPass.creator=m_Task;
-    virtualRenderPass.readers.push_back(m_Task);
-    virtualRenderPass.desc=renderPassDesc;
-    virtualRenderPass.id=m_Graph.m_ResourceAccessor->CreateSlot<DeviceRenderPass>(virtualRenderPass.desc).id;
-    
-    m_Graph.m_AccessIdToResourceIndex[virtualRenderPass.id.handle]=m_Graph.m_Resources.size();
-    read(virtualRenderPass.id.handle);
-    m_Task->renderPass=virtualRenderPass.id;
+    auto renderPassDesc = m_Graph.RenderPassDescToDeviceRenderPassDesc(desc);
+    auto virtualRenderPassPtr = CreateScope<VirtualResource<DeviceRenderPass>>();
     m_Graph.m_Resources.emplace_back(std::move(virtualRenderPassPtr));
+    auto& virtualRenderPass = *static_cast<VirtualResource<DeviceRenderPass>*>(m_Graph.m_Resources.back().get());
+    virtualRenderPass.creator = m_Task;
+    virtualRenderPass.readers.push_back(m_Task.Get());
+    virtualRenderPass.desc = renderPassDesc;
+    virtualRenderPass.id = m_Graph.m_ResourceAccessor->CreateSlot<DeviceRenderPass>(virtualRenderPass.desc).id;
+
+    m_Graph.m_AccessIdToResourceIndex[virtualRenderPass.id.handle] = m_Graph.m_Resources.size()-1;
+    read(virtualRenderPass.id.handle);
+    m_Task->renderPass = virtualRenderPass.id;
+    
     // allocate frame buffer
-    auto frameBufferDesc=m_Graph.RenderPassDescToFrameBufferDesc(desc);
-    auto virtualFrameBufferPtr=CreateScope<VirtualResource<DeviceFrameBuffer>>();
-    auto& virtualFrameBuffer=*virtualFrameBufferPtr;
-    virtualFrameBuffer.creator=m_Task;
-    virtualFrameBuffer.readers.push_back(m_Task);
-    virtualFrameBuffer.desc=frameBufferDesc;
-    virtualFrameBuffer.id=m_Graph.m_ResourceAccessor->CreateSlot<DeviceFrameBuffer>(virtualFrameBuffer.desc).id;
-    m_Graph.m_AccessIdToResourceIndex[virtualFrameBuffer.id.handle]=m_Graph.m_Resources.size();
-    read(virtualFrameBuffer.id.handle);
-    m_Task->frameBuffer=virtualFrameBuffer.id;
+    auto frameBufferDesc = m_Graph.RenderPassDescToFrameBufferDesc(desc);
+    auto virtualFrameBufferPtr = CreateScope<VirtualResource<DeviceFrameBuffer>>();
     m_Graph.m_Resources.emplace_back(std::move(virtualFrameBufferPtr));
+    auto& virtualFrameBuffer = *static_cast<VirtualResource<DeviceFrameBuffer>*>(m_Graph.m_Resources.back().get());
+    virtualFrameBuffer.creator = m_Task;
+    virtualFrameBuffer.readers.push_back(m_Task.Get());
+    virtualFrameBuffer.desc = frameBufferDesc;
+    virtualFrameBuffer.id = m_Graph.m_ResourceAccessor->CreateSlot<DeviceFrameBuffer>(virtualFrameBuffer.desc).id;
+    m_Graph.m_AccessIdToResourceIndex[virtualFrameBuffer.id.handle] = m_Graph.m_Resources.size()-1;
+    read(virtualFrameBuffer.id.handle);
+    m_Task->frameBuffer = virtualFrameBuffer.id;
+    
     return *this;
 }
 } // namespace Aether::RenderGraph
\ No newline at end of file
diff --git a/Render/src/Render/RenderGraph/RenderTask.h b/Render/src/Render/RenderGraph/RenderTask.h
index 50ec6db..d07175d 100644
--- a/Render/src/Render/RenderGraph/RenderTask.h
+++ b/Render/src/Render/RenderGraph/RenderTask.h
@@ -106,14 +106,14 @@ struct RenderTask : public RenderTaskBase
             VkClearValue clearValues[DeviceRenderPassDesc::MaxColorAttachments];
             for (size_t i = 0; i < renderPassDesc.colorAttachmentCount; ++i)
             {
-                clearValues[i].color = {renderPassDesc.clearColor[i].x, renderPassDesc.clearColor[i].y,
-                                        renderPassDesc.clearColor[i].z, renderPassDesc.clearColor[i].w};
+                clearValues[i].color = {renderPassDesc.clearColor[i].x(), renderPassDesc.clearColor[i].y(),
+                                        renderPassDesc.clearColor[i].z(), renderPassDesc.clearColor[i].w()};
                 clearValues[i].depthStencil.depth = renderPassDesc.clearDepth;
                 clearValues[i].depthStencil.stencil = renderPassDesc.clearStencil;
             }
-            auto& renderPassActual = resourceAccessor.GetResource(renderPass);
-            auto& frameBufferActual = resourceAccessor.GetResource(frameBuffer);
-            cb.BeginRenderPass(renderPassActual, frameBufferActual,
+            auto& renderPassActual = *resourceAccessor.GetResource(renderPass);
+            auto& frameBufferActual = *resourceAccessor.GetResource(frameBuffer);
+            cb.BeginRenderPass(renderPassActual.GetVk(), frameBufferActual.GetVk(),
                                std::span<VkClearValue>(clearValues, renderPassDesc.colorAttachmentCount));
         }
         execute(commandBuffer, resourceAccessor, data);
diff --git a/Render/src/Render/RenderGraph/Resource/ResourceAccessor.h b/Render/src/Render/RenderGraph/Resource/ResourceAccessor.h
index 05b6e12..f8cf058 100644
--- a/Render/src/Render/RenderGraph/Resource/ResourceAccessor.h
+++ b/Render/src/Render/RenderGraph/Resource/ResourceAccessor.h
@@ -9,12 +9,11 @@
 namespace Aether::RenderGraph
 {
 
-template<typename T>
+template <typename T>
 struct VirtualResourceInfo
 {
-
 };
-template<>
+template <>
 struct VirtualResourceInfo<DeviceTexture>
 {
     DeviceImageLayout layout = DeviceImageLayout::Undefined;
@@ -23,8 +22,7 @@ template <typename T>
 struct ResourceSlot
 {
     template <typename U>
-    ResourceSlot(U&& _desc) :
-        desc(std::forward<U>(_desc))
+    ResourceSlot(U&& _desc) : desc(std::forward<U>(_desc))
     {
     }
     ResourceSlot() = default;
@@ -35,21 +33,45 @@ struct ResourceSlot
 
     ResourceDescType<T>::Type desc;
     ResourceId<T> frameResources[Render::Config::InFlightFrameResourceSlots];
-    uint32_t resourceCount = 1; 
+    uint32_t resourceCount = 1;
     bool isRealized[Render::Config::InFlightFrameResourceSlots] = {false}; // if the resource is realized
-    bool external = false; // if the resource is created by the render graph
-    AccessId<T> id=AccessId<T>{.handle=Handle::CreateInvalid()}; // access id for the resource
-    VirtualResourceInfo<T> virtualInfo; // for image layout transition
+    bool external = false;                                           // if the resource is created by the render graph
+    AccessId<T> id = AccessId<T>{.handle = Handle::CreateInvalid()}; // access id for the resource
+    VirtualResourceInfo<T> virtualInfo;                              // for image layout transition
 };
 
 template <typename... Ts>
 class ResourceAccessorBase
 {
 public:
-    ResourceAccessorBase(Borrow<ResourceArena> resourceArena,Borrow<ResourceLruPool> resourcePool) :
-        m_ResourceArena(resourceArena), m_ResourcePool(resourcePool),m_FrameIndex(0)
+    void SetCurrentFrame(uint32_t frame)
+    {
+        m_FrameIndex=frame;
+    }
+    ResourceAccessorBase(Borrow<ResourceArena> resourceArena, Borrow<ResourceLruPool> resourcePool) :
+        m_ResourceArena(resourceArena), m_ResourcePool(resourcePool), m_FrameIndex(0)
     {
     }
+    ~ResourceAccessorBase()
+    {
+        ForEachInTuple(m_Slots, [&](auto&& indexedSlot) {
+            auto& slots = indexedSlot.m_Slots;
+            for (auto& slot : slots)
+            {
+                for (size_t i = 0; i < slot.resourceCount; ++i)
+                {
+                    if (slot.external)
+                    {
+                        continue;
+                    }
+                    if (slot.isRealized[i])
+                    {
+                        m_ResourcePool->PushResourceInUse(slot.frameResources[i], slot.desc);
+                    }
+                }
+            }
+        });
+    }
     template <typename ResourceType>
     ResourceType* GetResource(AccessId<ResourceType> id)
     {
@@ -61,10 +83,22 @@ public:
             return nullptr;
         }
         ResourceSlot<ResourceType>& slot = *iter->second;
-        uint32_t index=m_FrameIndex % slot.resourceCount;
-        if(!slot.isRealized[index])
+        uint32_t index = m_FrameIndex % slot.resourceCount;
+        if (!slot.isRealized[index])
         {
-            //slot.frameResources[index]=m_ResourcePool->PopOrCreate<ResourceType>(slot.desc);
+            if constexpr (std::is_same_v<ResourceType,DeviceImageView> )
+            {
+                auto resource=Realize<DeviceImageView>{*m_ResourceArena,*this,m_FrameIndex}(slot.desc);
+            }
+            else if constexpr (std::is_same_v<ResourceType,DeviceFrameBuffer>)
+            {
+
+            }
+            else
+            {
+
+            }
+            slot.frameResources[index]=m_ResourcePool->PopOrCreate<ResourceType>(slot.desc);
         }
         ResourceId<ResourceType> resourceId = slot.frameResources[index];
         // 从代码设计上，这里返回的id可能是无效id,但是如果没有在graph创建后再修改资源，不会出现无效id
@@ -88,8 +122,8 @@ public:
             assert(false && "Resource slot not found");
             return;
         }
-        slots.m_Slots.erase(*iter_to->second);
-        *iter_to->second = *iter_from->second;
+        slots.m_Slots.erase((*iter_to).second);
+        iter_to->second = iter_from->second;
     }
 
     template <typename ResourceType, typename ResourceDescType>
@@ -100,15 +134,16 @@ public:
         auto& slotMap = indexedSlots.m_SlotMap;
         AccessId<ResourceType> id = m_Allocator.Allocate<ResourceType>();
         ResourceSlot<ResourceType> slot(std::forward<ResourceDescType>(desc));
-        slot.resourceCount=1;
+        slot.resourceCount = 1;
         slot.id = id;
+        slot.desc = desc;
         slots.push_back(std::move(slot));
         auto iter = std::prev(slots.end());
         slotMap[id] = iter;
         SetSlotVirtualInfo<ResourceType>(desc, iter->virtualInfo);
         return slots.back();
     }
-    template<typename ResourceType>
+    template <typename ResourceType>
     bool SetSlotSupportsInFlightResources(AccessId<ResourceType> id)
     {
         auto& indexedSlots = std::get<IndexedSlot<ResourceType>>(m_Slots);
@@ -120,12 +155,16 @@ public:
             assert(false && "Resource slot not found");
             return false;
         }
-        ResourceSlot<ResourceType>& slot = *(*iter->second);
+        ResourceSlot<ResourceType>& slot = *((*iter).second);
+        if(slot.external)
+        {
+            return false;
+        }
         // only need one resource for read only in multi in-flight frames
         slot.resourceCount = Render::Config::MaxFramesInFlight;
         return true;
     }
-    template<typename ResourceType>
+    template <typename ResourceType>
     ResourceSlot<ResourceType>& GetSlot(AccessId<ResourceType> id)
     {
         auto& indexedSlots = std::get<IndexedSlot<ResourceType>>(m_Slots);
@@ -137,18 +176,20 @@ public:
         }
         return (*iter->second);
     }
-    
+
 private:
-    template<typename ResourceType>
-    void SetSlotVirtualInfo(const typename ResourceDescType<ResourceType>::Type& desc,VirtualResourceInfo<ResourceType>& info)
+    template <typename ResourceType>
+    void SetSlotVirtualInfo(const typename ResourceDescType<ResourceType>::Type& desc,
+                            VirtualResourceInfo<ResourceType>& info)
     {
-
     }
-    template<>
-    void SetSlotVirtualInfo<DeviceTexture>(const typename ResourceDescType<DeviceTexture>::Type& desc,VirtualResourceInfo<DeviceTexture>& info)
+    template <>
+    void SetSlotVirtualInfo<DeviceTexture>(const typename ResourceDescType<DeviceTexture>::Type& desc,
+                                           VirtualResourceInfo<DeviceTexture>& info)
     {
-        info.layout=desc.layout;
+        info.layout = desc.layout;
     }
+
 private:
     Borrow<ResourceArena> m_ResourceArena;
     Borrow<ResourceLruPool> m_ResourcePool;
@@ -157,26 +198,25 @@ private:
     struct IndexedSlot
     {
         std::list<ResourceSlot<ResourceType>> m_Slots;
-        std::unordered_map<AccessId<ResourceType>, typename std::list<ResourceSlot<ResourceType>>::iterator, Hash<AccessId<ResourceType>>> m_SlotMap;
+        std::unordered_map<AccessId<ResourceType>, typename std::list<ResourceSlot<ResourceType>>::iterator,
+                           Hash<AccessId<ResourceType>>>
+            m_SlotMap;
     };
     std::tuple<IndexedSlot<Ts>...> m_Slots;
     AccessIdAllocator m_Allocator;
 };
 namespace Detail
 {
-    template<typename T>
-    struct BuildResourceAccessor;
-    template<typename... Ts>
-    struct BuildResourceAccessor<TypeArray<Ts...>>
-    {
-        using Type = ResourceAccessorBase<Ts...>;
-    };
-}
+template <typename T>
+struct BuildResourceAccessor;
+template <typename... Ts>
+struct BuildResourceAccessor<TypeArray<Ts...>>
+{
+    using Type = ResourceAccessorBase<Ts...>;
+};
+} // namespace Detail
 using ResourceAccessor = typename Detail::BuildResourceAccessor<ResourceTypeArray>::Type;
 
-
-
-
 template <>
 struct Realize<DeviceImageView>
 {
@@ -185,10 +225,10 @@ struct Realize<DeviceImageView>
     uint32_t frameIndex;
     Scope<DeviceImageView> operator()(const ImageViewDesc& desc)
     {
-        auto& textureSlot=accessor.GetSlot(desc.texture);
-        uint32_t textureIndex=frameIndex%textureSlot.resourceCount;
+        auto& textureSlot = accessor.GetSlot(desc.texture);
+        uint32_t textureIndex = frameIndex % textureSlot.resourceCount;
         assert(textureSlot.isRealized[textureIndex]);
-        auto& textureId=textureSlot.frameResources[textureIndex];
+        auto& textureId = textureSlot.frameResources[textureIndex];
         assert(textureId.handle.IsValid());
         DeviceTexture* texture = arena.GetResource(textureId);
         if (!texture || texture->Empty())
@@ -223,7 +263,7 @@ struct Realize<DeviceFrameBuffer>
         for (size_t i = 0; i < desc.colorAttachmentCount; ++i)
         {
             auto& attachment = desc.colorAttachments[i];
-            auto& imageViewSlot=accessor.GetSlot(attachment.imageView);
+            auto& imageViewSlot = accessor.GetSlot(attachment.imageView);
             uint32_t imageViewIndex = frameIndex % imageViewSlot.resourceCount;
             assert(imageViewSlot.isRealized[imageViewIndex]);
             assert(imageViewSlot.frameResources[imageViewIndex].handle.IsValid());
@@ -252,12 +292,4 @@ struct Realize<DeviceFrameBuffer>
     }
 };
 
-
-
-
-
-
-
-
-
 } // namespace Aether::RenderGraph
\ No newline at end of file
diff --git a/Render/src/Render/RenderGraph/Resource/ResourceLruPool.h b/Render/src/Render/RenderGraph/Resource/ResourceLruPool.h
index 41a73e8..24b2389 100644
--- a/Render/src/Render/RenderGraph/Resource/ResourceLruPool.h
+++ b/Render/src/Render/RenderGraph/Resource/ResourceLruPool.h
@@ -160,7 +160,7 @@ public:
     void PushResourceInUse(ResourceId<T> resourceId,const typename ResourceDescType<T>::Type& desc)
     {
         auto& resourceList = std::get<std::vector<ResourceInUse<T>>>(m_ResourceInUseList.resources);
-        resourceList.push_back({desc,resourceId, Render::Config::MaxFramesInFlight});
+        resourceList.push_back({desc,resourceId, (uint32_t)Render::Config::MaxFramesInFlight});
     }
     void OnFrameBegin()
     {
diff --git a/Render/src/Render/RenderGraph/Resource/VirtualResource.h b/Render/src/Render/RenderGraph/Resource/VirtualResource.h
index be1509b..8f0ff8b 100644
--- a/Render/src/Render/RenderGraph/Resource/VirtualResource.h
+++ b/Render/src/Render/RenderGraph/Resource/VirtualResource.h
@@ -16,7 +16,11 @@ struct VirtualResourceBase
     TaskBase* creator = nullptr;
     ResourceCode code;
     size_t refCount = 0;            // for culling when compile
-    size_t lastAccessTaskIndex = 0; // for resource aliasing when compile
+    int64_t lastAccessTaskIndex = -1; // for resource aliasing when compile
+    inline bool Transient()const
+    {
+        return creator!=nullptr;
+    }
 };
 
 
@@ -31,6 +35,7 @@ struct VirtualResource : public VirtualResourceBase
     VirtualResource(const typename ResourceDescType<ResourceType>::Type& _desc, const AccessId<ResourceType>& _id) :
         desc(_desc), id(_id)
     {
+        code = GetResourceCode<ResourceType>::value;
     }
     VirtualResource()
     {
diff --git a/Render/src/Render/Vulkan/Buffer.cpp b/Render/src/Render/Vulkan/Buffer.cpp
index d468296..93000ea 100644
--- a/Render/src/Render/Vulkan/Buffer.cpp
+++ b/Render/src/Render/Vulkan/Buffer.cpp
@@ -67,23 +67,6 @@ bool Buffer::SyncCopy(const GraphicsCommandPool& commandPool, Buffer& src, Buffe
     copyRegion.dstOffset = dstOffset;
     copyRegion.size = size;
     vkCmdCopyBuffer(commandBuffer->GetHandle(), src.GetHandle(), dst.GetHandle(), 1, &copyRegion);
-    //// insert memory barrier
-    // VkBufferMemoryBarrier barrier{};
-    // barrier.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
-    // barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
-    // barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
-    // barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
-    // barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
-    // barrier.buffer = dst.GetHandle();
-    // barrier.offset = dstOffset;
-    // barrier.size = size;
-    // vkCmdPipelineBarrier(commandBuffer->GetHandle(),
-    //                      VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
-    //                      0,
-    //                      0, nullptr,
-    //                      1, &barrier,
-    //                      0, nullptr);
-
     commandBuffer->End();
     commandBuffer->BeginSubmit()
         .Fence(fence)
diff --git a/Render/src/Render/Vulkan/Buffer.h b/Render/src/Render/Vulkan/Buffer.h
index 752898e..567573a 100644
--- a/Render/src/Render/Vulkan/Buffer.h
+++ b/Render/src/Render/Vulkan/Buffer.h
@@ -8,6 +8,7 @@
 #include <type_traits>
 #include "vma/vk_mem_alloc.h"
 #include <cstring>
+
 namespace Aether {
 class Application;
 namespace vk {
@@ -57,6 +58,7 @@ public:
     static bool SyncCopy(const GraphicsCommandPool& commandPool, Buffer& src, Buffer& dst, size_t size);
     static bool SyncCopy(const GraphicsCommandPool& commandPool, Buffer& src, Buffer& dst, size_t size, size_t srcOffset, size_t dstOffset);
     static bool SyncCopy(Buffer& src, Buffer& dst, size_t size, size_t srcOffset, size_t dstOffset);
+    
 public:
     static std::optional<Buffer> Create(size_t size, Usage usage, Property properties);
     static std::optional<Buffer> CreateForStaging(size_t size)
diff --git a/Render/src/Render/Vulkan/GlobalRenderContext.cpp b/Render/src/Render/Vulkan/GlobalRenderContext.cpp
index 0d24286..d489e42 100644
--- a/Render/src/Render/Vulkan/GlobalRenderContext.cpp
+++ b/Render/src/Render/Vulkan/GlobalRenderContext.cpp
@@ -72,6 +72,7 @@ void GlobalRenderContext::Init(Window* window, bool enableValidationLayers)
     //vk::GRC::GetMainWindow().CreateSyncObjects();
     vk::Allocator::Init();
     window->CreateFinalImage();
+    window->InitRenderGraphResource();
 }
 void GlobalRenderContext::Cleanup()
 {
diff --git a/Render/src/Render/Vulkan/RenderContext.cpp b/Render/src/Render/Vulkan/RenderContext.cpp
index 1fd3429..34f4d36 100644
--- a/Render/src/Render/Vulkan/RenderContext.cpp
+++ b/Render/src/Render/Vulkan/RenderContext.cpp
@@ -52,8 +52,6 @@ void RenderContext::InitVulkan()
     CreateLogicalDevice();
     m_Window->CreateSwapChain(m_Instance, m_PhysicalDevice, m_Device);
     m_Window->CreateImageViews();
-    m_Window->CreateRenderPass(m_Window->m_SwapChainImageFormat);
-    m_Window->CreateFramebuffers();
     m_Window->CreateSyncObjects();
     m_QueueFamilyIndices = findQueueFamilies(m_PhysicalDevice, m_Window->GetSurface());
     // CreateCommandPool();
diff --git a/Render/src/Render/Vulkan/Transfer.cpp b/Render/src/Render/Vulkan/Transfer.cpp
new file mode 100644
index 0000000..b13ce5f
--- /dev/null
+++ b/Render/src/Render/Vulkan/Transfer.cpp
@@ -0,0 +1,13 @@
+#include "Transfer.h"
+namespace Aether::vk
+{
+void AsyncCopyBuffer(GraphicsCommandBuffer& commandBuffer, Buffer& src, Buffer& dst, size_t size, size_t srcOffset,
+                     size_t dstOffset)
+{
+    VkBufferCopy copyRegion{};
+    copyRegion.srcOffset = srcOffset;
+    copyRegion.dstOffset = dstOffset;
+    copyRegion.size = size;
+    vkCmdCopyBuffer(commandBuffer.GetHandle(), src.GetHandle(), dst.GetHandle(), 1, &copyRegion);
+}
+} // namespace Aether::vk
\ No newline at end of file
diff --git a/Render/src/Render/Vulkan/Transfer.h b/Render/src/Render/Vulkan/Transfer.h
new file mode 100644
index 0000000..84151a3
--- /dev/null
+++ b/Render/src/Render/Vulkan/Transfer.h
@@ -0,0 +1,7 @@
+#pragma once
+#include "GraphicsCommandBuffer.h"
+#include "Buffer.h"
+namespace Aether::vk
+{
+    void AsyncCopyBuffer(GraphicsCommandBuffer& commandBuffer,Buffer& src,Buffer& dst,size_t size,size_t srcOffset,size_t dstOffset);
+}
\ No newline at end of file
diff --git a/Scripts/CreateProjectWithTestsAndDemoDebug.bat b/Scripts/CreateProjectWithTestsAndDemoDebug.bat
new file mode 100644
index 0000000..67eb54b
--- /dev/null
+++ b/Scripts/CreateProjectWithTestsAndDemoDebug.bat
@@ -0,0 +1,6 @@
+cd ..
+cmake  -B Build -S .    -DCMAKE_BUILD_TYPE=Debug -G "Visual Studio 17 2022" -A x64 -DAETHER_RUNTIME_CHECK=1 -DAETHER_ENABLE_DEBUG_LOG=1  -DCMAKE_INSTALL_PREFIX=Packages -DAETHER_BUILD_DEMO=1 -DAETHER_BUILD_TESTS=1
+cmake  -B DummyBuild -S .   -DCMAKE_EXPORT_COMPILE_COMMANDS=on -DCMAKE_BUILD_TYPE=Debug -G Ninja -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang -DAETHER_RUNTIME_CHECK=1 -DAETHER_ENABLE_DEBUG_LOG=1 -DAETHER_BUILD_DEMO=1 -DAETHER_BUILD_TESTS=1
+cp DummyBuild/compile_commands.json .
+cd Scripts
+pause
\ No newline at end of file
diff --git a/Sprite/CMakeLists.txt b/Sprite/CMakeLists.txt
index 2bfc5ba..a3fa55a 100644
--- a/Sprite/CMakeLists.txt
+++ b/Sprite/CMakeLists.txt
@@ -5,8 +5,8 @@ endif()
 
 set(MODULE_NAME Sprite)
 file(GLOB_RECURSE FILES
-"${CMAKE_CURRENT_SOURCE_DIR}/Source/*.cpp" 
-"${CMAKE_CURRENT_SOURCE_DIR}/Source/*.h"
+"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp" 
+"${CMAKE_CURRENT_SOURCE_DIR}/src/*.h"
 )
 
 add_library(${MODULE_NAME} STATIC ${FILES})
@@ -17,7 +17,7 @@ target_include_directories(${MODULE_NAME} PUBLIC
     $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/Source/Public>
     $<INSTALL_INTERFACE:${MODULE_NAME}/include>
 )
-target_include_directories(${MODULE_NAME} PRIVATE "Source/Private")
+target_include_directories(${MODULE_NAME} PRIVATE "src")
 target_link_libraries(${MODULE_NAME} PUBLIC Core
 Render
 Resource
@@ -34,7 +34,7 @@ install(TARGETS ${MODULE_NAME}
 
 include(CMakePackageConfigHelpers)
 # install时拷贝头文件
-install(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/Source/Public/"
+install(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/src/"
     DESTINATION ${MODULE_NAME}/include
     FILES_MATCHING PATTERN "*.h"
 )
diff --git a/Sprite/Source/Sprite/Atlas.cpp b/Sprite/src/Sprite/Atlas.cpp
similarity index 100%
rename from Sprite/Source/Sprite/Atlas.cpp
rename to Sprite/src/Sprite/Atlas.cpp
diff --git a/Sprite/Source/Sprite/Atlas.h b/Sprite/src/Sprite/Atlas.h
similarity index 100%
rename from Sprite/Source/Sprite/Atlas.h
rename to Sprite/src/Sprite/Atlas.h
diff --git a/Sprite/Source/Sprite/Quad.h b/Sprite/src/Sprite/Quad.h
similarity index 100%
rename from Sprite/Source/Sprite/Quad.h
rename to Sprite/src/Sprite/Quad.h
diff --git a/Sprite/Source/Sprite/Renderer.cpp b/Sprite/src/Sprite/Renderer.cpp
similarity index 100%
rename from Sprite/Source/Sprite/Renderer.cpp
rename to Sprite/src/Sprite/Renderer.cpp
diff --git a/Sprite/Source/Sprite/Renderer.h b/Sprite/src/Sprite/Renderer.h
similarity index 100%
rename from Sprite/Source/Sprite/Renderer.h
rename to Sprite/src/Sprite/Renderer.h
diff --git a/Tests/Render.Tests/RenderGraphTests/src/RenderGraphTests.cpp b/Tests/Render.Tests/RenderGraphTests/src/RenderGraphTests.cpp
index 6f95731..71e4ae7 100644
--- a/Tests/Render.Tests/RenderGraphTests/src/RenderGraphTests.cpp
+++ b/Tests/Render.Tests/RenderGraphTests/src/RenderGraphTests.cpp
@@ -32,23 +32,11 @@ class TestLayer : public Layer
 public:
     ~TestLayer()
     {
-        m_RenderGraph.reset();
-        m_ResourceLruPool.reset();
-    }
-    virtual void OnRender(DeviceCommandBuffer& _commandBuffer) override
-    {
-        m_RenderGraph->SetCommandBuffer(&_commandBuffer);
-        m_RenderGraph->Execute();
-        // auto& commandBuffer = _commandBuffer.GetVk();
-        // commandBuffer.BeginRenderPass(m_RenderPass.GetVk(), m_Framebuffer.GetVk(), Vec4f(1.0f, 1.0f, 1.0f, 1.0f));
-        // commandBuffer.SetViewport(0, 0, m_Framebuffer.GetSize().x(), m_Framebuffer.GetSize().y());
-        // commandBuffer.SetScissor(0, 0, m_Framebuffer.GetSize().x(), m_Framebuffer.GetSize().y());
-        // commandBuffer.BindPipeline(*m_Pipeline);
-        // Render::Utils::DrawMesh(commandBuffer, *m_Mesh);
-        // commandBuffer.EndRenderPass();
     }
+
     virtual void OnAttach(Window* window) override
     {
+        m_Window = window;
         // create command buffer pool
         m_CommandPool = vk::GraphicsCommandPool::CreateScope();
         //// create cpu grid
@@ -71,68 +59,39 @@ public:
             desc.colorAttachments[0].format = PixelFormat::RGBA8888;
             desc.colorAttachments[0].loadOp = DeviceAttachmentLoadOp::Clear;
             desc.colorAttachments[0].storeOp = DeviceAttachmentStoreOp::Store;
-            m_RenderPass = DeviceRenderPass::Create(desc);
-        }
-        {
-            DeviceFrameBufferDesc desc;
-            desc.colorAttachmentCount = 1;
-            desc.colorAttachments[0] = &window->GetFinalTexture().GetOrCreateDefaultImageView();
-            desc.width = window->GetSize().x();
-            desc.height = window->GetSize().y();
-            m_Framebuffer = DeviceFrameBuffer::Create(m_RenderPass, desc);
-        }
-        {
+            auto renderPass = DeviceRenderPass::Create(desc);
             // create pipeline
             vk::PipelineLayout::Builder layoutBuilder;
             auto pipelineLayout = layoutBuilder.Build();
-            vk::GraphicsPipeline::Builder pipelineBuilder(m_RenderPass.GetVk(), *pipelineLayout);
+            vk::GraphicsPipeline::Builder pipelineBuilder(renderPass.GetVk(), *pipelineLayout);
             pipelineBuilder.AddFragmentStage(*m_FragmentShader, "main");
             pipelineBuilder.AddVertexStage(*m_VertexShader, "main");
             pipelineBuilder.PushVertexBufferLayouts(m_Mesh->GetVertexBufferLayouts());
             m_Pipeline = pipelineBuilder.BuildScope();
         }
-        { // build RenderGraph
-            // create render graph
-            {
-                m_ResourceArena = CreateScope<RenderGraph::ResourceArena>();
-                m_ResourceLruPool = CreateScope<RenderGraph::ResourceLruPool>(*m_ResourceArena);
-                m_RenderGraph = CreateScope<RenderGraph::RenderGraph>(m_ResourceArena.get(), m_ResourceLruPool.get());
-            }
-            RenderGraph::AccessId<DeviceTexture> finalTextureId;
-            // import final texture
-            {
-                auto& finalTexture = window->GetFinalTexture();
-                auto resourceId = m_ResourceArena->Import(&finalTexture);
-                auto& accessor = m_RenderGraph->GetResourceAccessor();
-                auto& slot = accessor.CreateExternalSlot<DeviceTexture>(resourceId);
-                finalTextureId = slot.id;
-            }
-            // create render task
-            {
-                struct TaskData
-                {
-                };
-                Vec2i size = window->GetSize();
-                auto taskData = m_RenderGraph->AddRenderTask<TaskData>(
-                    [&](RenderGraph::RenderTaskBuilder& builder, TaskData& data) {
-                        auto imageView = builder.Create<DeviceImageView>(
-                            RenderGraph::ImageViewDesc{.texture = finalTextureId, .desc = {}});
-                        RenderGraph::RenderPassDesc renderPassDesc;
-                        renderPassDesc.colorAttachmentCount = 1;
-                        renderPassDesc.colorAttachment[0].imageView = imageView;
-                        builder.SetRenderPassDesc(renderPassDesc);
-                    },
-                    [size, this](DeviceCommandBuffer& _commandBuffer, RenderGraph::ResourceAccessor& accessor,
-                                 TaskData& data) {
-                        auto& commandBuffer = _commandBuffer.GetVk();
-                        commandBuffer.SetViewport(0, 0, size.x(), size.y());
-                        commandBuffer.SetScissor(0, 0, size.x(), size.y());
-                        commandBuffer.BindPipeline(*m_Pipeline);
-                        Render::Utils::DrawMesh(commandBuffer, *m_Mesh);
-                    });
-            }
-            m_RenderGraph->Compile();
-        }
+    }
+    virtual void RegisterRenderPasses(RenderGraph::RenderGraph& renderGraph) override
+    {
+        struct TaskData
+        {
+        };
+        Vec2i size = m_Window->GetSize();
+        auto taskData = renderGraph.AddRenderTask<TaskData>(
+            [&](RenderGraph::RenderTaskBuilder& builder, TaskData& data) {
+                auto imageView = builder.Create<DeviceImageView>(
+                    RenderGraph::ImageViewDesc{.texture = m_Window->GetFinalImageAccessId(), .desc = {}});
+                RenderGraph::RenderPassDesc renderPassDesc;
+                renderPassDesc.colorAttachmentCount = 1;
+                renderPassDesc.colorAttachment[0].imageView = imageView;
+                builder.SetRenderPassDesc(renderPassDesc);
+            },
+            [size, this](DeviceCommandBuffer& _commandBuffer, RenderGraph::ResourceAccessor& accessor, TaskData& data) {
+                auto& commandBuffer = _commandBuffer.GetVk();
+                commandBuffer.SetViewport(0, 0, size.x(), size.y());
+                commandBuffer.SetScissor(0, 0, size.x(), size.y());
+                commandBuffer.BindPipeline(*m_Pipeline);
+                Render::Utils::DrawMesh(commandBuffer, *m_Mesh);
+            });
     }
 
 private:
@@ -142,13 +101,7 @@ private:
     Scope<vk::DescriptorSet> m_DescriptorSet;
     Scope<vk::ShaderModule> m_VertexShader;
     Scope<vk::ShaderModule> m_FragmentShader;
-    DeviceRenderPass m_RenderPass;
-    DeviceFrameBuffer m_Framebuffer;
-
-private:
-    Scope<RenderGraph::RenderGraph> m_RenderGraph;
-    Scope<RenderGraph::ResourceArena> m_ResourceArena;
-    Scope<RenderGraph::ResourceLruPool> m_ResourceLruPool;
+    Window* m_Window = nullptr;
 };
 
 class RenderGraphTests : public Application
diff --git a/Window/src/Window/GammaFilter.cpp b/Window/src/Window/GammaFilter.cpp
index 780e606..6fd77cb 100644
--- a/Window/src/Window/GammaFilter.cpp
+++ b/Window/src/Window/GammaFilter.cpp
@@ -54,7 +54,7 @@ bool GammaFilter::CreatePipeline(const vk::RenderPass& renderPass)
 }
 bool GammaFilter::CreateDescriptor(DeviceDescriptorPool& pool)
 {
-    auto set = pool.CreateSet(1, 0, 1);
+    auto set = pool.CreateSet(0, 0, 1);
     if (!set)
     {
         return false;
@@ -62,10 +62,9 @@ bool GammaFilter::CreateDescriptor(DeviceDescriptorPool& pool)
     m_DescriptorSet = std::move(set);
     return true;
 }
-bool GammaFilter::Render(DeviceTexture& _from, DeviceFrameBufferView _to, DeviceCommandBufferView _commandBuffer,DeviceDescriptorPool& pool)
+bool GammaFilter::Render(DeviceTexture& _from, DeviceCommandBufferView _commandBuffer,DeviceDescriptorPool& pool)
 {
     auto& from = _from.GetVk();
-    auto& to = _to.GetVk();
     auto& commandBuffer = _commandBuffer.GetVk();
     auto& descriptorResource = m_DescriptorSet.GetVk();
     auto& pipeline = m_Pipeline.GetVk();
@@ -89,19 +88,6 @@ bool GammaFilter::Render(DeviceTexture& _from, DeviceFrameBufferView _to, Device
 bool GammaFilter::UpdateDescriptor(DeviceTexture& from)
 {
     auto& descriptorResource = m_DescriptorSet.GetVk();
-
-    // update uniform buffer
-    {
-        // update buffer data
-        m_UniformBuffer.SetData(reinterpret_cast<uint8_t*>(&m_HostUniformBuffer), sizeof(m_HostUniformBuffer));
-        // update descriptor binding
-        auto& uboAccessor = descriptorResource.ubos[0];
-        auto& set = descriptorResource.sets[uboAccessor.set];
-        auto binding = uboAccessor.binding;
-        vk::DescriptorSetOperator op(set);
-        op.BindUBO(binding, m_UniformBuffer.GetVk());
-        op.Apply();
-    }
     // update texture sampler
     {
         auto& accessor = descriptorResource.samplers[0];
diff --git a/Window/src/Window/GammaFilter.h b/Window/src/Window/GammaFilter.h
index a59889a..1298c15 100644
--- a/Window/src/Window/GammaFilter.h
+++ b/Window/src/Window/GammaFilter.h
@@ -23,7 +23,6 @@ public:
     DeviceDescriptorPool& pool)
     {
         GammaFilter filter;
-        filter.m_UniformBuffer=DeviceBuffer::CreateForUniform(sizeof(UniformBuffer));
         if (!filter.CreateSampler())
         {
             return std::unexpected<std::string>("CreateSampler failed");
@@ -47,11 +46,8 @@ public:
         
         return filter;
     }
-    bool Render(DeviceTexture& from,DeviceFrameBufferView to,DeviceCommandBufferView commandBuffer,DeviceDescriptorPool& pool);
-    void SetGamma(float gamma)
-    {
-        m_HostUniformBuffer.gamma=gamma;
-    }
+    bool Render(DeviceTexture& from,DeviceCommandBufferView commandBuffer,DeviceDescriptorPool& pool);
+
 
 private:
     bool UpdateDescriptor(DeviceTexture& from);// per frame
@@ -61,7 +57,6 @@ private:
     DevicePipelineLayout m_PipelineLayout;
     DeviceDescriptorSet m_DescriptorSet;
     Mesh m_Mesh;
-    DeviceBuffer m_UniformBuffer;
     DeviceMesh m_DeviceMesh;
     DeviceSampler m_Sampler;
     bool CreateSampler();
@@ -76,10 +71,7 @@ private:
         }
         return true;
     }
-    struct UniformBuffer
-    {
-        float gamma=2.2f;
-    } m_HostUniformBuffer;
+
     bool CreatePipeline(const vk::RenderPass& renderPass);
     bool CreateDescriptor(DeviceDescriptorPool& pool);// per frame
     bool CreateShader()
@@ -89,14 +81,11 @@ private:
 layout(location=0) in vec2 v_TexCoord;
 layout(location=0) out vec4 FragColor;
 layout(set=1,binding=0) uniform sampler2D u_Texture;
-layout(set=0,binding=0) uniform UniformBuffer
-{
-    float gamma;
-}ubo;
+
 void main()
 {
 vec4 textureColor=texture(u_Texture,v_TexCoord);
-FragColor=vec4(pow(textureColor.rgb,vec3(ubo.gamma)),textureColor.a);
+FragColor=vec4(pow(textureColor.rgb,vec3(2.2)),textureColor.a);
 }
 )";
         static const char* vert = R"(
diff --git a/Window/src/Window/Layer.h b/Window/src/Window/Layer.h
index 5210e29..c4d2739 100644
--- a/Window/src/Window/Layer.h
+++ b/Window/src/Window/Layer.h
@@ -1,6 +1,7 @@
 #pragma once
 #include "Window/Event.h"
 #include <Render/RenderApi.h>
+#include <Render/RenderGraph/RenderGraph.h>
 namespace Aether {
 class Window;
 class Layer
@@ -22,13 +23,16 @@ public:
     {
     }
 
-    virtual void OnRender(
-        DeviceCommandBuffer& commandBuffer
-    )
+    virtual void OnFrameBegin()
     {
     }
-    virtual void OnFrameBegin()
+    virtual void RegisterRenderPasses(RenderGraph::RenderGraph& renderGraph)
+    {
+
+    }
+    virtual bool NeedRebuildRenderGraph() const
     {
+        return false;
     }
    
 };
diff --git a/Window/src/Window/Window.cpp b/Window/src/Window/Window.cpp
index 454a520..b122fd0 100644
--- a/Window/src/Window/Window.cpp
+++ b/Window/src/Window/Window.cpp
@@ -114,6 +114,15 @@ void Window::PushLayer(Layer* layer)
     m_Layers.emplace_back(layer);
 
     layer->OnAttach(this);
+    CreateRenderGraph();
+}
+void Window::PushLayers(const std::span<Layer*>& layers)
+{
+    for (auto* layer : layers)
+    {
+        PushLayer(layer);
+    }
+    CreateRenderGraph();
 }
 void Window::PopLayer(Layer* layer)
 {
@@ -148,14 +157,7 @@ std::vector<vk::ImageView>& Window::GetImageViews()
 {
     return m_SwapChainImageViews;
 }
-const std::vector<vk::FrameBuffer>& Window::GetFrameBuffers() const
-{
-    return m_SwapChainFramebuffers;
-}
-std::vector<vk::FrameBuffer>& Window::GetFrameBuffers()
-{
-    return m_SwapChainFramebuffers;
-}
+
 void Window::CreateCommandBuffer()
 {
     for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++)
@@ -172,8 +174,6 @@ bool Window::CreateRenderObject()
     CreateSurface(instance);
     CreateSwapChain(instance, physicalDevice, device);
     CreateImageViews();
-    CreateRenderPass(m_SwapChainImageFormat);
-    CreateFramebuffers();
     CreateSyncObjects();
     CreateCommandBuffer();
     bool res = CreateFinalImage();
@@ -181,71 +181,85 @@ bool Window::CreateRenderObject()
     {
         return false;
     }
+    InitRenderGraphResource();
     return true;
 }
 bool Window::CreateFinalImage()
 {
     auto size = GetSize();
-    auto textureOpt = DeviceTexture::CreateForColorAttachment(size.x(), size.y(), PixelFormat::RGBA8888);
-    if (!textureOpt)
-    {
-        assert(false && "DeviceTexture::CreateForTexture failed");
-        return false;
-    }
-    auto& texture = *textureOpt;
-    auto renderPassOpt = vk::RenderPass::CreateDefault(PixelFormat::RGBA8888);
+    VkExtent2D extent{(uint32_t)size.x(), (uint32_t)size.y()};
+    // create tonemap render pass
+
+    auto renderPassOpt = vk::RenderPass::CreateForPresent(m_SwapChainImageFormat);
     if (!renderPassOpt)
     {
         assert(false && "RenderPass::CreateDefault failed");
         return false;
     }
-    m_FinalRenderPass = DeviceRenderPass(std::move(renderPassOpt.value()));
+    m_TonemapRenderPass = DeviceRenderPass(std::move(renderPassOpt.value()));
+    // create final image(layer will render to final image)
+    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
+    {
+        auto textureOpt = DeviceTexture::CreateForColorAttachment(size.x(), size.y(), PixelFormat::RGBA8888);
+        if (!textureOpt)
+        {
+            assert(false && "DeviceTexture::CreateForTexture failed");
+            return false;
+        }
+        auto& texture = *textureOpt;
+        texture.SyncTransitionLayout(DeviceImageLayout::Undefined, DeviceImageLayout::Texture);
 
-    VkExtent2D extent{(uint32_t)size.x(), (uint32_t)size.y()};
-    auto framebufferOpt =
-        vk::FrameBuffer::Create(m_FinalRenderPass.GetVk(), extent, texture.GetOrCreateDefaultImageView().GetVk());
-    if (!framebufferOpt)
+        m_FinalTextures[i] = std::move(texture);
+    }
+
+    // create tonemap framebuffer
+    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
     {
-        assert(false && "FrameBuffer::Create failed");
-        return false;
+        auto framebufferOpt = vk::FrameBuffer::Create(m_TonemapRenderPass.GetVk(), extent, m_SwapChainImageViews[i]);
+        if (!framebufferOpt)
+        {
+            assert(false && "FrameBuffer::Create failed");
+            return false;
+        }
+        auto& framebuffer = *framebufferOpt;
+        m_TonemapFrameBuffers[i] = std::move(framebuffer);
     }
-    auto& framebuffer = *framebufferOpt;
-    auto poolOpt = DeviceDescriptorPool::Create();
-    if (!poolOpt)
+    // create descriptor pool
+    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
     {
-        assert(false && "DeviceDescriptorPool::Create failed");
-        return false;
+        auto poolOpt = DeviceDescriptorPool::Create();
+        if (!poolOpt)
+        {
+            assert(false && "DeviceDescriptorPool::Create failed");
+            return false;
+        }
+        auto& pool = *poolOpt;
+        m_DescriptorPools[i] = std::move(pool);
     }
-    auto& pool = *poolOpt;
-    auto filterOpt = WindowInternal::GammaFilter::Create(*m_RenderPass[0], pool);
+    // create gamma filter
+
+    auto filterOpt = WindowInternal::GammaFilter::Create(m_TonemapRenderPass.GetVk(), m_DescriptorPools[0]);
     if (!filterOpt)
     {
         assert(false && "GammaFilter::Create failed");
         return false;
     }
     m_GammaFilter = CreateScope<WindowInternal::GammaFilter>(std::move(filterOpt.value()));
-    m_GammaFilter->SetGamma(2.2f);
-    texture.SyncTransitionLayout(DeviceImageLayout::Undefined, DeviceImageLayout::Texture);
-
-    m_FinalTexture = std::move(texture);
-    m_FinalFrameBuffer = DeviceFrameBuffer(std::move(framebuffer));
-    m_DescriptorPool = std::move(pool);
 }
 void Window::ReleaseFinalImage()
 {
-    m_FinalTexture = DeviceTexture();
-    m_FinalFrameBuffer = DeviceFrameBuffer();
-    m_FinalRenderPass = DeviceRenderPass();
+    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
+    {
+        m_FinalTextures[i] = DeviceTexture();
+        m_TonemapFrameBuffers[i] = DeviceFrameBuffer();
+        m_DescriptorPools[i] = DeviceDescriptorPool();
+    }
+
+    m_TonemapRenderPass = DeviceRenderPass();
     m_GammaFilter.reset();
-    m_DescriptorPool = DeviceDescriptorPool();
 }
 void Window::ReleaseRenderObject()
 {
-    m_SwapChainFramebuffers.clear();
-    for (auto& renderPass : m_RenderPass)
-    {
-        renderPass.reset();
-    }
     m_SwapChainImageViews.clear();
     m_SwapChainImages.clear();
     if (m_SwapChain != VK_NULL_HANDLE)
@@ -264,32 +278,15 @@ void Window::ReleaseRenderObject()
         m_GraphicsCommandBuffer[i] = DeviceCommandBuffer();
     }
     ReleaseFinalImage();
+    m_RenderGraph.reset();
+    m_ResourcePool.reset();
+    m_ResourceArena.reset();
 }
 VkSurfaceKHR Window::GetSurface() const
 {
     return m_Surface;
 }
-vk::RenderPass& Window::GetRenderPass(uint32_t index) const
-{
-    return *m_RenderPass[index];
-}
-
-/**
- * @brief create framebuffers
- */
-void Window::CreateFramebuffers()
-{
-    for (size_t i = 0; i < m_SwapChainImageViews.size(); i++)
-    {
-        auto framebufferOpt = vk::FrameBuffer::Create(*m_RenderPass[i], m_SwapChainExtent, m_SwapChainImageViews[i]);
-        if (!framebufferOpt.has_value())
-        {
-            assert(false && "FrameBuffer::Create failed");
-        }
 
-        m_SwapChainFramebuffers.emplace_back(std::move(framebufferOpt.value()));
-    }
-}
 /**
  * @brief create surface
  */
@@ -420,69 +417,74 @@ void Window::OnUpdate(float sec)
     {
         layer->OnUpdate(sec);
     }
+    bool anyLayerNeedRebuild = false;
+    for (auto& layer : m_Layers)
+    {
+        if (layer->NeedRebuildRenderGraph())
+        {
+            anyLayerNeedRebuild = true;
+            break;
+        }
+    }
+    if(anyLayerNeedRebuild)
+    {
+        CreateRenderGraph();
+    }
 }
-void Window::WaitLastFrameComplete()
-{
-    m_CommandBufferFences[m_CurrentFrame]->Wait();
-}
+
 void Window::OnRender()
 {
+    // wait for render resource
+    m_CommandBufferFences[m_CurrentFrame]->Wait();
+
+    // acquire next image
+    uint32_t imageIndex;
+    auto& imageAvailableSemaphore = *m_ImageAvailableSemaphore[m_CurrentFrame];
+    VkResult result = vkAcquireNextImageKHR(vk::GRC::GetDevice(), m_SwapChain, UINT64_MAX,
+                                            imageAvailableSemaphore.GetHandle(), VK_NULL_HANDLE, &imageIndex);
+
+    if (result != VK_SUCCESS)
+    {
+        assert(false && "unknown error");
+        return;
+    }
+    m_DescriptorPools[m_CurrentFrame].Clear();
+
     for (auto* layer : m_Layers)
     {
         layer->OnFrameBegin();
     }
-    m_DescriptorPool.Clear();
     if (m_Layers.empty())
         return;
     if (GetSize().x() == 0 || GetSize().y() == 0)
         return;
 
-    // async acquire next image
-    uint32_t imageIndex;
-    VkResult result =
-        vkAcquireNextImageKHR(vk::GRC::GetDevice(), m_SwapChain, UINT64_MAX,
-                              m_ImageAvailableSemaphore[m_CurrentFrame]->GetHandle(), VK_NULL_HANDLE, &imageIndex);
-    if (result != VK_SUCCESS)
-    {
-        return;
-    }
-    m_CommandBufferFences[m_CurrentFrame]->Reset();
-
     // record command buffer
-    size_t lastFrame = (m_CurrentFrame + MAX_FRAMES_IN_FLIGHT - 1) % MAX_FRAMES_IN_FLIGHT;
     auto& curCommandBuffer = m_GraphicsCommandBuffer[m_CurrentFrame].GetVk();
-    auto& curRenderPass = *m_RenderPass[m_CurrentFrame];
-    auto& curFrameBuffer = m_SwapChainFramebuffers[imageIndex];
-    Vec4f clearColor(0.0f, 0.0f, 0.0f, 1.0f);
     curCommandBuffer.Reset();
     curCommandBuffer.Begin();
     // curCommandBuffer.BeginRenderPass(curRenderPass, curFrameBuffer,clearColor);
-    m_FinalTexture.AsyncTransitionLayout(DeviceImageLayout::Texture, DeviceImageLayout::ColorAttachment,
-                                         curCommandBuffer);
-    for (size_t i = 0; i < m_Layers.size(); ++i)
-    {
-        auto* layer = m_Layers[i];
-        // layer->OnRender(*m_RenderPass[m_CurrentFrame],
-        //                 m_SwapChainFramebuffers[imageIndex],
-        //                 *m_GraphicsCommandBuffer[m_CurrentFrame]);
-        layer->OnRender(m_GraphicsCommandBuffer[m_CurrentFrame]);
-    }
-    // render to screen
-    m_FinalTexture.AsyncTransitionLayout(DeviceImageLayout::ColorAttachment, DeviceImageLayout::Texture,
-                                         curCommandBuffer);
-    curCommandBuffer.BeginRenderPass(*m_RenderPass[m_CurrentFrame], m_SwapChainFramebuffers[imageIndex],
+    m_FinalTextures[m_CurrentFrame].AsyncTransitionLayout(DeviceImageLayout::Texture,
+                                                          DeviceImageLayout::ColorAttachment, curCommandBuffer);
+    m_RenderGraph->SetCommandBuffer(&m_GraphicsCommandBuffer[m_CurrentFrame]);
+    m_RenderGraph->SetCurrentFrame(m_CurrentFrame);
+    m_RenderGraph->Execute();
+    // render to screen (tonemap)
+    m_FinalTextures[m_CurrentFrame].AsyncTransitionLayout(DeviceImageLayout::ColorAttachment,
+                                                          DeviceImageLayout::Texture, curCommandBuffer);
+    curCommandBuffer.BeginRenderPass(m_TonemapRenderPass.GetVk(), m_TonemapFrameBuffers[imageIndex].GetVk(),
                                      Vec4f(0.0, 0.0, 0.0, 1.0));
     curCommandBuffer.SetScissor(0, 0, GetSize().x(), GetSize().y());
     curCommandBuffer.SetViewport(0, 0, GetSize().x(), GetSize().y());
-    m_GammaFilter->Render(m_FinalTexture, m_SwapChainFramebuffers[imageIndex], curCommandBuffer, m_DescriptorPool);
+    m_GammaFilter->Render(m_FinalTextures[m_CurrentFrame], curCommandBuffer, m_DescriptorPools[m_CurrentFrame]);
     curCommandBuffer.EndRenderPass();
     // curCommandBuffer.EndRenderPass();
     curCommandBuffer.End();
     // commit command buffer
-    auto imageAvailableSemaphore = m_ImageAvailableSemaphore[m_CurrentFrame]->GetHandle();
+    auto imageAvailableSemaphoreHandle = imageAvailableSemaphore.GetHandle();
     static VkPipelineStageFlags stage = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT;
     auto renderFinishedSemaphore = m_RenderFinishedSemaphore[m_CurrentFrame]->GetHandle();
-    m_GraphicsCommandBuffer[m_CurrentFrame].GetVk().Submit(1, &imageAvailableSemaphore, &stage, 1,
+    m_GraphicsCommandBuffer[m_CurrentFrame].GetVk().Submit(1, &imageAvailableSemaphoreHandle, &stage, 1,
                                                            &renderFinishedSemaphore,
                                                            m_CommandBufferFences[m_CurrentFrame]->GetHandle());
     // async present
@@ -496,6 +498,9 @@ void Window::OnRender()
     presentInfo.pSwapchains = swapChains;
     presentInfo.pImageIndices = &imageIndex;
     vkQueuePresentKHR(vk::GRC::GetPresentQueue().GetHandle(), &presentInfo);
+
+    // forward current frame index
+    m_CurrentFrame = (m_CurrentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
 }
 bool Window::CreateSyncObjects()
 {
@@ -539,44 +544,45 @@ Input& Window::GetInput()
     return m_Input;
 }
 
-void Window::CreateRenderPass(VkFormat format)
-{
-    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++)
-    {
-        m_RenderPass[i] = std::make_unique<vk::RenderPass>(*vk::RenderPass::CreateForPresent(format));
-    }
-}
 bool Window::ReleaseVulkanObjects()
 {
     ReleaseRenderObject();
     return ReleaseSyncObjects();
 }
-DeviceTexture& Window::GetFinalTexture()
+DeviceTexture& Window::GetFinalTexture(uint32_t index)
 {
-    return m_FinalTexture;
+    return m_FinalTextures[index];
 }
 bool Window::ResizeFinalImage(const Vec2u& size)
 {
-    auto textureOpt = DeviceTexture::CreateForColorAttachment(size.x(), size.y(), PixelFormat::RGBA8888);
-    if (!textureOpt)
+    VkExtent2D extent{(uint32_t)size.x(), (uint32_t)size.y()};
+    // create final image(layer will render to final image)
+    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
     {
-        assert(false && "DeviceTexture::CreateForTexture failed");
-        return false;
+        auto textureOpt = DeviceTexture::CreateForColorAttachment(size.x(), size.y(), PixelFormat::RGBA8888);
+        if (!textureOpt)
+        {
+            assert(false && "DeviceTexture::CreateForTexture failed");
+            return false;
+        }
+        auto& texture = *textureOpt;
+        texture.SyncTransitionLayout(DeviceImageLayout::Undefined, DeviceImageLayout::Texture);
+
+        m_FinalTextures[i] = std::move(texture);
     }
-    auto& texture = *textureOpt;
-    VkExtent2D extent{(uint32_t)size.x(), (uint32_t)size.y()};
-    auto framebufferOpt =
-        vk::FrameBuffer::Create(m_FinalRenderPass.GetVk(), extent, texture.GetOrCreateDefaultImageView().GetVk());
-    if (!framebufferOpt)
+
+    // create tonemap framebuffer
+    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
     {
-        assert(false && "FrameBuffer::Create failed");
-        return false;
+        auto framebufferOpt = vk::FrameBuffer::Create(m_TonemapRenderPass.GetVk(), extent, m_SwapChainImageViews[i]);
+        if (!framebufferOpt)
+        {
+            assert(false && "FrameBuffer::Create failed");
+            return false;
+        }
+        auto& framebuffer = *framebufferOpt;
+        m_TonemapFrameBuffers[i] = std::move(framebuffer);
     }
-    auto& framebuffer = *framebufferOpt;
-    texture.SyncTransitionLayout(DeviceImageLayout::Undefined, DeviceImageLayout::Texture);
-    m_FinalTexture = std::move(texture);
-    m_FinalFrameBuffer = DeviceFrameBuffer(std::move(framebuffer));
-    return true;
 }
 void Window::OnWindowResize(const Vec2u& size)
 {
@@ -585,5 +591,37 @@ void Window::OnWindowResize(const Vec2u& size)
         return; // no need to resize
     }
     assert(ResizeFinalImage(size) && "failed to resize window final image");
+    CreateRenderGraph();
+}
+void Window::InitRenderGraphResource()
+{
+    m_ResourceArena = CreateScope<RenderGraph::ResourceArena>();
+    m_ResourcePool = CreateScope<RenderGraph::ResourceLruPool>(m_ResourceArena.get());
+}
+void Window::CreateRenderGraph()
+{
+    // create
+    m_RenderGraph = CreateScope<RenderGraph::RenderGraph>(m_ResourceArena.get(), m_ResourcePool.get());
+    // import final image
+    RenderGraph::ResourceId<DeviceTexture> finalImageResourceIds[MAX_FRAMES_IN_FLIGHT];
+    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
+    {
+        finalImageResourceIds[i] = m_ResourceArena->Import(&m_FinalTextures[i]);
+    }
+    RenderGraph::TextureDesc finalImageDesc;
+    finalImageDesc.usages = PackFlags(DeviceImageUsage::ColorAttachment , DeviceImageUsage::Sample);
+    finalImageDesc.pixelFormat = PixelFormat::RGBA8888;
+    finalImageDesc.width = m_FinalTextures[0].GetWidth();
+    finalImageDesc.height = m_FinalTextures[0].GetHeight();
+    finalImageDesc.layout = DeviceImageLayout::ColorAttachment;
+    m_FinalImageAccessId = m_RenderGraph->Import(
+        finalImageDesc, std::span<RenderGraph::ResourceId<DeviceTexture>>(finalImageResourceIds, MAX_FRAMES_IN_FLIGHT));
+    // call each layer's RegisterRenderPasses function
+    for(auto* layer:m_Layers)
+    {
+        layer->RegisterRenderPasses(*m_RenderGraph);
+    }
+    // compile
+    m_RenderGraph->Compile();
 }
 } // namespace Aether
\ No newline at end of file
diff --git a/Window/src/Window/Window.h b/Window/src/Window/Window.h
index 7fbcd93..d74ca15 100644
--- a/Window/src/Window/Window.h
+++ b/Window/src/Window/Window.h
@@ -17,6 +17,7 @@
 #include "Render/Vulkan/ImageView.h"
 #include "Input.h"
 #include "GammaFilter.h"
+#include "Render/RenderGraph/RenderGraph.h"
 namespace Aether {
 namespace vk {
 class RenderContext;
@@ -49,61 +50,67 @@ public:
      *   只是把layer挂在到window，不转移所有权
      */
     void PushLayer(Layer* layer);
+    void PushLayers(const std::span<Layer*>& layers);
     void PopLayer(Layer* layer);
     VkSwapchainKHR GetSwapchain() const;
     const std::vector<VkImage>& GetImages() const;
     std::vector<VkImage>& GetImages();
     const std::vector<vk::ImageView>& GetImageViews() const;
     std::vector<vk::ImageView>& GetImageViews();
-    const std::vector<vk::FrameBuffer>& GetFrameBuffers() const;
-    std::vector<vk::FrameBuffer>& GetFrameBuffers();
     bool CreateRenderObject();
     void ReleaseRenderObject();
     bool CreateSyncObjects();
     bool ReleaseSyncObjects();
     bool ReleaseVulkanObjects();
     VkSurfaceKHR GetSurface() const;
-    vk::RenderPass& GetRenderPass(uint32_t index) const;
     Vec2i GetSize() const;
     void OnUpdate(float sec);
     void OnRender();
     void PushEvent(const Event& e);
     Input& GetInput();
 
-    void WaitLastFrameComplete();
     void ReleaseFinalImage();
     bool CreateFinalImage();
-    DeviceTexture& GetFinalTexture();
+    DeviceTexture& GetFinalTexture(uint32_t index);
     void SetSize(uint32_t width, uint32_t height);
+    uint32_t GetCurrentFrameIndex()
+    {
+        return m_CurrentFrame;
+    }
+    RenderGraph::AccessId<DeviceTexture> GetFinalImageAccessId() const
+    {
+        return m_FinalImageAccessId;
+    }
+    DeviceDescriptorPool& GetCurrentDescriptorPool()
+    {
+        return m_DescriptorPools[m_CurrentFrame];
+    }
+    // create resource arena and lru pool
+    void InitRenderGraphResource();
 private:
     std::vector<Event> m_Event;
     std::vector<Layer*> m_Layers;
     VkSwapchainKHR m_SwapChain = VK_NULL_HANDLE;
     std::vector<VkImage> m_SwapChainImages;
     std::vector<vk::ImageView> m_SwapChainImageViews;
-    std::vector<vk::FrameBuffer> m_SwapChainFramebuffers;
     VkFormat m_SwapChainImageFormat{};
     VkExtent2D m_SwapChainExtent{};
     VkSurfaceKHR m_Surface = VK_NULL_HANDLE;
     GLFWwindow* m_Handle=nullptr;
-    std::unique_ptr<vk::RenderPass> m_RenderPass[MAX_FRAMES_IN_FLIGHT];
     std::unique_ptr<vk::Semaphore> m_ImageAvailableSemaphore[MAX_FRAMES_IN_FLIGHT];
     std::unique_ptr<vk::Semaphore> m_RenderFinishedSemaphore[MAX_FRAMES_IN_FLIGHT];
     Scope<vk::Fence> m_CommandBufferFences[MAX_FRAMES_IN_FLIGHT];
     DeviceCommandBuffer m_GraphicsCommandBuffer[MAX_FRAMES_IN_FLIGHT];
-    uint32_t m_CurrentFrame = 0;
     //=========== final image
-    DeviceTexture m_FinalTexture;
-    DeviceFrameBuffer m_FinalFrameBuffer;
-    DeviceRenderPass m_FinalRenderPass; 
+    DeviceTexture m_FinalTextures[MAX_FRAMES_IN_FLIGHT];
+    DeviceFrameBuffer m_TonemapFrameBuffers[MAX_FRAMES_IN_FLIGHT];
+    DeviceRenderPass m_TonemapRenderPass; 
     Scope<WindowInternal::GammaFilter> m_GammaFilter;
-    DeviceDescriptorPool m_DescriptorPool;
+    DeviceDescriptorPool m_DescriptorPools[MAX_FRAMES_IN_FLIGHT];
     //================================
+    uint32_t m_CurrentFrame=0;
 private:
-    /**
-     * @brief create framebuffers
-     */
-    void CreateFramebuffers();
+
     /**
      * @brief create surface
      */
@@ -121,11 +128,21 @@ private:
      *@brief Create swapchain image views
      */
     void CreateImageViews();
-    void CreateRenderPass(VkFormat format);
     void CreateCommandBuffer();
     bool ResizeFinalImage(const Vec2u& size);
     void OnWindowResize(const Vec2u& size);
 private:
     Input m_Input;
+private://render graph
+    Scope<RenderGraph::ResourceArena> m_ResourceArena;
+    Scope<RenderGraph::ResourceLruPool> m_ResourcePool;
+    Scope<RenderGraph::RenderGraph> m_RenderGraph;
+    
+    // create render graph, register final image
+    // and call each layer RegisterRenderPasses function
+    void CreateRenderGraph();
+    RenderGraph::AccessId<DeviceTexture> m_FinalImageAccessId;
+
+
 };
 } // namespace Aether
\ No newline at end of file
-- 
2.44.0.windows.1

